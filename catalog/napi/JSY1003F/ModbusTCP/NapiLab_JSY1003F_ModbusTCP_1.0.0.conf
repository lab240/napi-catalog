## Modbus TCP sensor configuration
[[inputs.modbus]]
  name = "JSY1003F"
  slave_id = 1
  timeout = "1s"
  controller = "tcp://localhost:502"

  ## Digital inputs to read from the device
  holding_registers = [
    {  measurement="JSY1003F", name = "voltage", byte_order = "AB", data_type = "UINT16", scale = 1.0, address = [72] },
    { measurement="JSY1003F", name = "current", byte_order = "AB", data_type = "UINT16", scale = 1.0, address = [73] },
    { measurement="JSY1003F", name = "power", byte_order = "AB", data_type = "UINT16", scale = 1.0, address = [74] },
    { measurement="JSY1003F", name = "freq", byte_order = "AB", data_type = "UINT16", scale = 1.0, address = [81] },
    { measurement="JSY1003F", name = "energy", byte_order = "AB", data_type = "UINT16", scale = 1.0, address = [75] },
    { measurement="JSY1003F", name = "energy1", byte_order = "AB", data_type = "UINT16", scale = 1.0, address = [76] },
    { measurement="JSY1003F", name = "powerfactor", byte_order = "AB", data_type = "UINT16", scale = 1.0, address = [77] },
    { measurement="JSY1003F", name = "current_range", byte_order = "AB", data_type = "UINT16", scale = 1.0, address = [3] }
  ]



[[processors.starlark]]
 # Reads the Starlark script embedded

  source = '''

load("logging.star", "log")
def apply(metric):

  metric.fields["z_multiplier_current"]=1000
  metric.fields["z_multiplier_pf"]=1000
  metric.fields["z_multiplier_energy"]=3200
  metric.fields["z_multiplier_energy1"]=3200
  metric.fields["z_multiplier_power"]=10
  metric.fields["z_multiplier_freq"]=100
  metric.fields["z_multiplier_voltage"]=100

  return metric
'''
